# PRP: Modernize MRTG Remote Sensor to PHP 8.3+ with Composer

**Date Created**: 2025-11-13
**Target PHP Version**: 8.3+
**Implementation Style**: One-pass comprehensive refactoring

---

## Executive Summary

Transform the legacy PHP 5.x MRTG Remote Sensor codebase into a modern PHP 8.3+ Composer-managed project following PSR-4 autoloading, PSR-12 coding standards, and contemporary best practices. The refactoring will maintain 100% backward compatibility in API endpoints while modernizing the internal architecture.

---

## Current State Analysis

### Existing Codebase Structure
```
.
â”œâ”€â”€ index.php           # Main entry point (56 lines)
â”œâ”€â”€ test.php            # Test file
â”œâ”€â”€ overview.html       # Interactive testing UI
â”œâ”€â”€ test.html           # Simple test UI
â””â”€â”€ lib/
    â”œâ”€â”€ settings.inc    # Simple include loader (6 lines)
    â”œâ”€â”€ tools.php       # Cache class + utilities (195 lines)
    â”œâ”€â”€ sensors.php     # Sensor class with all metrics (524 lines)
    â””â”€â”€ ostools.inc     # OStools class for OS abstraction (600 lines)
```

### Key Classes Identified
1. **Cache** (`lib/tools.php:23`) - File-based caching with automatic cleanup
2. **Sensor** (`lib/sensors.php:5`) - Main sensor logic, 16 public methods
3. **OStools** (`lib/ostools.inc:4`) - OS-specific command execution (Windows, Linux, macOS, BusyBox)

### Critical Methods to Preserve (API Contract)

**Sensor Class Methods**:
- `cpuusage($aspercent=false)` - Line 88
- `memusage($aspercent=false)` - Line 141
- `battery($type="")` - Line 177
- `diskusage($path=false,$aspercent=false)` - Line 287
- `foldersize($folder,$options)` - Line 327
- `filecount($folder,$options)` - Line 352
- `proccount($filter=false)` - Line 383
- `pingtime($address,$port=80)` - Line 409
- `foldercount($folder,$options)` - Line 438
- `mrtg_output($params,$withconfig=false)` - Line 49
- `digest($text,$length=4,$keep=1)` - Line 471
- `parse_options($options)` - Line 476
- `sanitize($text)` - Line 502
- `tcpping($ip,$port)` - Line 509

**OStools Class Methods**:
- `memusage()` - Line 24
- `cpuload()` - Line 58
- `cpucount()` - Line 92
- `cpuinfo()` - Line 268
- `proccount($filter=false)` - Line 121
- `diskusage($path)` - Line 174
- `foldersize($path,$recursive=false)` - Line 219
- `uptime()` - Line 331
- `battery()` - Line 379

### Legacy PHP Patterns to Modernize
- Old-style class constructors (`function __construct()` without type hints)
- No type declarations on properties or methods
- Global `$debug` variable usage
- Inconsistent error handling (mix of `return false` and empty returns)
- Old array syntax `Array()` instead of `[]`
- No namespacing
- Direct `$_GET` access via custom `getparam()` function
- No dependency injection (classes instantiate dependencies internally)

---

## Target Architecture

### Directory Structure
```
mrtg_remote_sensor/
â”œâ”€â”€ composer.json               # Composer configuration
â”œâ”€â”€ composer.lock               # Locked dependencies
â”œâ”€â”€ phpunit.xml                 # PHPUnit configuration
â”œâ”€â”€ phpstan.neon                # PHPStan static analysis config
â”œâ”€â”€ .php-cs-fixer.php          # PHP-CS-Fixer configuration
â”œâ”€â”€ .gitignore                  # Updated for Composer
â”œâ”€â”€ README.md                   # Updated with modern setup
â”œâ”€â”€ CLAUDE.md                   # Updated documentation
â”œâ”€â”€ src/                        # PSR-4 autoloaded source
â”‚   â”œâ”€â”€ Cache/
â”‚   â”‚   â””â”€â”€ FileCache.php      # Refactored Cache class
â”‚   â”œâ”€â”€ Sensor/
â”‚   â”‚   â”œâ”€â”€ Sensor.php         # Main sensor class
â”‚   â”‚   â”œâ”€â”€ SensorResult.php   # Value object for results
â”‚   â”‚   â””â”€â”€ MrtgFormatter.php  # MRTG output formatting
â”‚   â”œâ”€â”€ OS/
â”‚   â”‚   â”œâ”€â”€ OSDetector.php     # OS detection
â”‚   â”‚   â”œâ”€â”€ OSTools.php        # Base class
â”‚   â”‚   â”œâ”€â”€ WindowsTools.php   # Windows-specific
â”‚   â”‚   â”œâ”€â”€ LinuxTools.php     # Linux-specific
â”‚   â”‚   â”œâ”€â”€ DarwinTools.php    # macOS-specific
â”‚   â”‚   â””â”€â”€ BusyBoxTools.php   # BusyBox-specific
â”‚   â”œâ”€â”€ Command/
â”‚   â”‚   â”œâ”€â”€ CommandExecutor.php # Command execution with caching
â”‚   â”‚   â””â”€â”€ CommandResult.php   # Value object for command results
â”‚   â”œâ”€â”€ Http/
â”‚   â”‚   â”œâ”€â”€ Request.php        # Request handling
â”‚   â”‚   â””â”€â”€ Response.php       # Response handling
â”‚   â””â”€â”€ Enum/
â”‚       â”œâ”€â”€ SensorType.php     # Enum for sensor types
â”‚       â””â”€â”€ OSType.php         # Enum for OS types
â”œâ”€â”€ public/                     # Web root
â”‚   â”œâ”€â”€ index.php              # Single entry point
â”‚   â”œâ”€â”€ overview.html          # Testing UI (moved)
â”‚   â””â”€â”€ test.html              # Simple UI (moved)
â”œâ”€â”€ config/
â”‚   â””â”€â”€ sensors.php            # Sensor configuration
â”œâ”€â”€ tests/                     # PHPUnit tests
â”‚   â”œâ”€â”€ Unit/
â”‚   â”‚   â”œâ”€â”€ Cache/
â”‚   â”‚   â”œâ”€â”€ Sensor/
â”‚   â”‚   â”œâ”€â”€ OS/
â”‚   â”‚   â””â”€â”€ Command/
â”‚   â””â”€â”€ Integration/
â”‚       â””â”€â”€ SensorIntegrationTest.php
â””â”€â”€ var/                       # Runtime data
    â”œâ”€â”€ cache/                 # Cache files
    â””â”€â”€ logs/                  # Application logs
```

### PSR-4 Namespace Structure
```
MrtgSensor\Cache\FileCache
MrtgSensor\Sensor\Sensor
MrtgSensor\Sensor\SensorResult
MrtgSensor\Sensor\MrtgFormatter
MrtgSensor\OS\OSDetector
MrtgSensor\OS\OSTools
MrtgSensor\OS\WindowsTools
MrtgSensor\OS\LinuxTools
MrtgSensor\OS\DarwinTools
MrtgSensor\OS\BusyBoxTools
MrtgSensor\Command\CommandExecutor
MrtgSensor\Command\CommandResult
MrtgSensor\Http\Request
MrtgSensor\Http\Response
MrtgSensor\Enum\SensorType
MrtgSensor\Enum\OSType
```

---

## PHP 8.3+ Features to Leverage

### 1. Typed Class Constants
```php
// Before (legacy)
class Sensor {
    var $version = "1.4";
}

// After (PHP 8.3+)
class Sensor {
    public const string VERSION = '1.4';
}
```

### 2. Constructor Property Promotion
```php
// Before
class CommandResult {
    private $stdout;
    private $exitCode;

    public function __construct($stdout, $exitCode) {
        $this->stdout = $stdout;
        $this->exitCode = $exitCode;
    }
}

// After
class CommandResult {
    public function __construct(
        private readonly array $stdout,
        private readonly int $exitCode
    ) {}
}
```

### 3. Enums for Fixed Values
```php
enum SensorType: string {
    case CPU = 'cpu';
    case CPU_PERCENT = 'cpu%';
    case MEMORY = 'mem';
    case MEMORY_PERCENT = 'mem%';
    case DISK = 'disk';
    case DISK_PERCENT = 'disk%';
    case BATTERY = 'battery';
    case BATTERY_PERCENT = 'battery%';
    case BATTERY_INVERSE = 'battery-';
    case BATTERY_VOLTAGE = 'batt_volt';
    case BATTERY_AMPERE = 'batt_amp';
    case BATTERY_CYCLES = 'batt_cycles';
    case PROCESS_COUNT = 'proc';
    case FOLDER_SIZE = 'foldersize';
    case FILE_COUNT = 'filecount';
    case FOLDER_COUNT = 'foldercount';
    case PING_TIME = 'pingtime';
}

enum OSType: string {
    case WINDOWS = 'winnt';
    case LINUX = 'linux';
    case DARWIN = 'darwin';
    case BUSYBOX = 'busybox';
}
```

### 4. Readonly Properties
```php
class SensorResult {
    public function __construct(
        public readonly float|int $value1,
        public readonly float|int|string $value2,
        public readonly string $uptime,
        public readonly string $server,
        public readonly string $name1,
        public readonly string $name2,
        public readonly string $description,
        public readonly string $mrtgUnit,
        public readonly string $mrtgOptions,
        public readonly int $mrtgMaxBytes,
        public readonly string $mrtgKmg,
    ) {}
}
```

### 5. Match Expressions
```php
// Before
switch($key) {
    case "cpu": $values = $s->cpuusage(); break;
    case "cpu%": $values = $s->cpuusage(true); break;
    case "mem": $values = $s->memusage(); break;
    default: echo "Unknown key";
}

// After
$values = match($sensorType) {
    SensorType::CPU => $sensor->cpuusage(),
    SensorType::CPU_PERCENT => $sensor->cpuusage(true),
    SensorType::MEMORY => $sensor->memusage(),
    SensorType::MEMORY_PERCENT => $sensor->memusage(true),
    default => throw new InvalidArgumentException("Unknown sensor type: {$sensorType->value}")
};
```

### 6. #[\Override] Attribute
```php
abstract class OSTools {
    abstract public function cpuload(): array;
}

class LinuxTools extends OSTools {
    #[\Override]
    public function cpuload(): array {
        // Implementation
    }
}
```

### 7. Union Types & Null Safety
```php
// Strict typing everywhere
public function diskusage(?string $path = null, bool $asPercent = false): SensorResult
{
    $path ??= '.';
    // ... implementation
}
```

---

## Implementation Blueprint

### Phase 1: Project Setup (Foundation)

#### 1.1 Create composer.json
```json
{
    "name": "cinemapub/mrtg-remote-sensor",
    "description": "Modern PHP web service providing system metrics in MRTG-compatible format",
    "type": "project",
    "license": "MIT",
    "require": {
        "php": ">=8.3"
    },
    "require-dev": {
        "phpunit/phpunit": "^10.5",
        "phpstan/phpstan": "^1.10",
        "friendsofphp/php-cs-fixer": "^3.45",
        "phpstan/phpstan-strict-rules": "^1.5"
    },
    "autoload": {
        "psr-4": {
            "MrtgSensor\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "MrtgSensor\\Tests\\": "tests/"
        }
    },
    "scripts": {
        "test": "phpunit",
        "analyse": "phpstan analyse src --level=8",
        "format": "php-cs-fixer fix src",
        "check": [
            "@analyse",
            "@test"
        ]
    },
    "config": {
        "sort-packages": true,
        "optimize-autoloader": true
    }
}
```

#### 1.2 Create .gitignore
```gitignore
/vendor/
/var/cache/*
!/var/cache/.gitkeep
/var/logs/*
!/var/logs/.gitkeep
composer.lock
.php-cs-fixer.cache
.phpunit.result.cache
.DS_Store
```

#### 1.3 Create PHPUnit Configuration (phpunit.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
         cacheDirectory=".phpunit.cache"
         beStrictAboutOutputDuringTests="true"
         failOnRisky="true"
         failOnWarning="true">
    <testsuites>
        <testsuite name="Unit">
            <directory>tests/Unit</directory>
        </testsuite>
        <testsuite name="Integration">
            <directory>tests/Integration</directory>
        </testsuite>
    </testsuites>
    <source>
        <include>
            <directory>src</directory>
        </include>
    </source>
</phpunit>
```

#### 1.4 Create PHPStan Configuration (phpstan.neon)
```neon
parameters:
    level: 8
    paths:
        - src
    strictRules:
        allRules: true
```

#### 1.5 Create PHP-CS-Fixer Configuration (.php-cs-fixer.php)
```php
<?php

$finder = PhpCsFixer\Finder::create()
    ->in(__DIR__ . '/src')
    ->in(__DIR__ . '/tests');

return (new PhpCsFixer\Config())
    ->setRules([
        '@PSR12' => true,
        '@PHP83Migration' => true,
        'array_syntax' => ['syntax' => 'short'],
        'strict_param' => true,
        'declare_strict_types' => true,
    ])
    ->setFinder($finder);
```

#### 1.6 Create Directory Structure
```bash
mkdir -p src/{Cache,Sensor,OS,Command,Http,Enum}
mkdir -p public
mkdir -p config
mkdir -p tests/{Unit,Integration}
mkdir -p var/{cache,logs}
touch var/cache/.gitkeep var/logs/.gitkeep
```

### Phase 2: Core Value Objects & Enums

#### 2.1 Create src/Enum/SensorType.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Enum;

enum SensorType: string
{
    case CPU = 'cpu';
    case CPU_PERCENT = 'cpu%';
    case MEMORY = 'mem';
    case MEMORY_PERCENT = 'mem%';
    case DISK = 'disk';
    case DISK_PERCENT = 'disk%';
    case BATTERY = 'battery';
    case BATTERY_PERCENT = 'battery%';
    case BATTERY_INVERSE = 'battery-';
    case BATTERY_VOLTAGE = 'batt_volt';
    case BATTERY_AMPERE = 'batt_amp';
    case BATTERY_CYCLES = 'batt_cycles';
    case PROCESS_COUNT = 'proc';
    case FOLDER_SIZE = 'foldersize';
    case FILE_COUNT = 'filecount';
    case FOLDER_COUNT = 'foldercount';
    case PING_TIME = 'pingtime';

    public static function tryFromString(string $key): ?self
    {
        return self::tryFrom(strtolower($key));
    }
}
```

#### 2.2 Create src/Enum/OSType.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Enum;

enum OSType: string
{
    case WINDOWS = 'winnt';
    case LINUX = 'linux';
    case DARWIN = 'darwin';
    case BUSYBOX = 'busybox';
}
```

#### 2.3 Create src/Sensor/SensorResult.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Sensor;

final readonly class SensorResult
{
    public function __construct(
        public float|int|string $value1,
        public float|int|string $value2,
        public string $uptime,
        public string $server,
        public string $name1,
        public string $name2,
        public string $description,
        public string $mrtgUnit,
        public string $mrtgOptions,
        public int|float $mrtgMaxBytes,
        public string $mrtgKmg,
        public string $url,
        public string $cfgUrl,
        public string $mrtgName,
        public string $version,
    ) {}

    public function toArray(): array
    {
        return [
            'value1' => $this->value1,
            'value2' => $this->value2,
            'uptime' => $this->uptime,
            'server' => $this->server,
            'name1' => $this->name1,
            'name2' => $this->name2,
            'description' => $this->description,
            'mrtg_unit' => $this->mrtgUnit,
            'mrtg_options' => $this->mrtgOptions,
            'mrtg_maxbytes' => $this->mrtgMaxBytes,
            'mrtg_kmg' => $this->mrtgKmg,
            'url' => $this->url,
            'cfgurl' => $this->cfgUrl,
            'mrtg_name' => $this->mrtgName,
            'version' => $this->version,
        ];
    }
}
```

#### 2.4 Create src/Command/CommandResult.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Command;

final readonly class CommandResult
{
    public function __construct(
        public array $stdout,
        public int $exitCode = 0,
    ) {}

    public function isSuccess(): bool
    {
        return $this->exitCode === 0;
    }

    public function getFirstLine(): string
    {
        return $this->stdout[0] ?? '';
    }
}
```

### Phase 3: Cache System

#### 3.1 Create src/Cache/FileCache.php
Refactor from `lib/tools.php:23-142`

```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Cache;

final class FileCache
{
    private readonly string $cacheDir;
    private readonly bool $enabled;

    public function __construct(string $cacheDir = 'var/cache')
    {
        $this->cacheDir = $cacheDir;
        $this->enabled = $this->ensureCacheDir();
    }

    private function ensureCacheDir(): bool
    {
        if (is_dir($this->cacheDir)) {
            return true;
        }

        return @mkdir($this->cacheDir, 0777, true);
    }

    public function get(string $id, string $group = 'cache', int $maxSeconds = 295): ?string
    {
        if (!$this->enabled) {
            return null;
        }

        $cachefile = $this->makeFilename($id, $group);
        if (!file_exists($cachefile)) {
            return null;
        }

        $ageSeconds = time() - filemtime($cachefile);
        if ($ageSeconds > $maxSeconds) {
            return null;
        }

        return file_get_contents($cachefile) ?: null;
    }

    public function getArray(string $id, string $group = 'cache', int $maxSeconds = 295): ?array
    {
        $data = $this->get($id, $group, $maxSeconds);
        if ($data === null) {
            return null;
        }

        $result = unserialize($data);
        return is_array($result) ? $result : null;
    }

    public function set(string $id, string $group, string $value): bool
    {
        if (!$this->enabled) {
            return false;
        }

        if (random_int(0, 100) > 95) {
            $this->cleanup();
        }

        $cachefile = $this->makeFilename($id, $group);
        return file_put_contents($cachefile, $value) !== false;
    }

    public function setArray(string $id, string $group, array $array): bool
    {
        return $this->set($id, $group, serialize($array));
    }

    public function cleanup(int $hours = 24): void
    {
        if (!$this->enabled) {
            return;
        }

        $cacheFiles = glob("{$this->cacheDir}/*.temp") ?: [];
        $threshold = time() - ($hours * 3600);

        foreach ($cacheFiles as $cacheFile) {
            if (filemtime($cacheFile) < $threshold) {
                @unlink($cacheFile);
            }
        }
    }

    private function makeFilename(string $id, string $group): string
    {
        $group = strtolower(substr($group, 0, 10));
        $begin = preg_replace('/[^a-zA-Z0-9]/', '', $id);
        $begin = substr($begin, 0, 10);
        $cacheId = "{$group}.{$begin}." . substr(hash('sha256', $id), 0, 16);

        return "{$this->cacheDir}/{$cacheId}.temp";
    }
}
```

### Phase 4: Command Execution

#### 4.1 Create src/Command/CommandExecutor.php
Refactor from `lib/tools.php:144-170`

```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Command;

use MrtgSensor\Cache\FileCache;

final class CommandExecutor
{
    private const CACHE_CATEGORY = 'cli';

    public function __construct(
        private readonly FileCache $cache,
        private readonly bool $debug = false,
    ) {}

    public function execute(
        string $command,
        ?string $workingDirectory = null,
        int $cacheSeconds = 30
    ): CommandResult {
        $fullCommand = $workingDirectory
            ? "cd \"{$workingDirectory}\"; {$command}"
            : $command;

        // Try cache first
        if ($cacheSeconds > 0) {
            $cached = $this->cache->getArray($fullCommand, self::CACHE_CATEGORY, $cacheSeconds);
            if ($cached !== null) {
                if ($this->debug) {
                    error_log("[CommandExecutor] Cache hit: {$fullCommand}");
                }
                return new CommandResult($cached);
            }
        }

        // Execute command
        $stdout = [];
        $exitCode = 0;
        exec($fullCommand, $stdout, $exitCode);

        if ($this->debug) {
            error_log("[CommandExecutor] Executed: {$fullCommand} (" . count($stdout) . " lines)");
        }

        // Cache result
        if ($cacheSeconds > 0 && $stdout) {
            $this->cache->setArray($fullCommand, self::CACHE_CATEGORY, $stdout);
        }

        return new CommandResult($stdout, $exitCode);
    }
}
```

### Phase 5: OS Detection & Abstraction

#### 5.1 Create src/OS/OSDetector.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\OS;

use MrtgSensor\Enum\OSType;

final class OSDetector
{
    private static ?OSType $detectedOS = null;

    public static function detect(): OSType
    {
        if (self::$detectedOS !== null) {
            return self::$detectedOS;
        }

        $osName = strtolower(php_uname('s'));

        // Check for Synology/BusyBox
        if (is_dir('/usr/syno/synoman/')) {
            self::$detectedOS = OSType::BUSYBOX;
            return self::$detectedOS;
        }

        // Check for Windows
        if (str_starts_with($osName, 'windows')) {
            self::$detectedOS = OSType::WINDOWS;
            return self::$detectedOS;
        }

        // Check for Darwin (macOS)
        if ($osName === 'darwin') {
            self::$detectedOS = OSType::DARWIN;
            return self::$detectedOS;
        }

        // Default to Linux
        self::$detectedOS = OSType::LINUX;
        return self::$detectedOS;
    }
}
```

#### 5.2 Create src/OS/OSTools.php (Abstract Base)
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\OS;

use MrtgSensor\Command\CommandExecutor;

abstract class OSTools
{
    public function __construct(
        protected readonly CommandExecutor $executor,
    ) {}

    abstract public function cpuload(): array;
    abstract public function cpuinfo(): array;
    abstract public function memusage(): array;
    abstract public function diskusage(string $path): array;
    abstract public function foldersize(string $path): array;
    abstract public function uptime(): string;
    abstract public function proccount(?string $filter): array;

    // Optional - not all OS support battery
    public function battery(): ?array
    {
        return null;
    }
}
```

#### 5.3 Create OS-Specific Implementations
Each OS class (WindowsTools, LinuxTools, DarwinTools, BusyBoxTools) extends OSTools and uses the `#[\Override]` attribute. Implementation details extracted from `lib/ostools.inc`.

**Example: src/OS/LinuxTools.php** (partial - full implementation needed)
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\OS;

final class LinuxTools extends OSTools
{
    #[\Override]
    public function cpuload(): array
    {
        $load = sys_getloadavg();
        return [
            '1min' => round($load[0], 3),
            '5min' => round($load[1], 3),
            '15min' => round($load[2], 3),
        ];
    }

    #[\Override]
    public function memusage(): array
    {
        $result = $this->executor->execute('free | grep Mem');
        $line = preg_replace('/\s\s*/', "\t", trim($result->getFirstLine()));
        $parts = explode("\t", $line);

        return [
            'free' => (int)($parts[3] ?? 0),
            'used' => (int)($parts[2] ?? 0),
            'total' => (int)($parts[1] ?? 0),
        ];
    }

    #[\Override]
    public function cpuinfo(): array
    {
        if (!is_readable('/proc/cpuinfo')) {
            return ['cores' => 1, 'ghz' => 1.0, 'bogomips' => 1000];
        }

        $cpuinfo = file_get_contents('/proc/cpuinfo');
        preg_match_all('/^processor/m', $cpuinfo, $matches);
        $cores = count($matches[0]);

        // Extract bogomips, cpu MHz, etc.
        // Full implementation from ostools.inc:268-328

        return [
            'cores' => $cores,
            'ghz' => 2.0, // Placeholder
            'bogomips' => 2000, // Placeholder
        ];
    }

    // ... other methods
}
```

### Phase 6: Main Sensor Class

#### 6.1 Create src/Sensor/Sensor.php
Refactor from `lib/sensors.php:5-522`

```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Sensor;

use MrtgSensor\OS\OSTools;
use MrtgSensor\Enum\SensorType;

final class Sensor
{
    public const string VERSION = '2.0';

    private readonly string $serverName;
    private readonly string $uptime;
    private readonly string $baseUrl;

    public function __construct(
        private readonly OSTools $osTools,
        string $serverName,
        string $scriptName,
        bool $isHttps = false,
    ) {
        $this->serverName = $serverName;
        $this->uptime = $this->osTools->uptime();
        $this->baseUrl = ($isHttps ? 'https://' : 'http://') . $serverName . $scriptName;
    }

    public function cpuusage(bool $asPercent = false): SensorResult
    {
        $cpuLoad = $this->osTools->cpuload();
        $cpuInfo = $this->osTools->cpuinfo();

        $load5 = $cpuLoad['5min'];
        $load15 = $cpuLoad['15min'];
        $cores = $cpuInfo['cores'];

        if (!$asPercent) {
            return new SensorResult(
                value1: $load5 * 100,
                value2: $load15 * 100,
                uptime: $this->uptime,
                server: "{$cores} cores x {$cpuInfo['ghz']} GHz",
                name1: 'Avg load over 5 min',
                name2: 'Avg load over 15 min',
                description: "{$this->serverName}: CPU (5/15 min - {$cores} CPUs)",
                mrtgUnit: 'load',
                mrtgOptions: 'growright,nobanner,gauge',
                mrtgMaxBytes: 500 * $cores,
                mrtgKmg: ',k,M,G,T,P',
                url: $this->buildUrl('cpu'),
                cfgUrl: $this->buildUrl('cpu', true),
                mrtgName: $this->buildCounterName('cpu'),
                version: self::VERSION,
            );
        }

        // Percentage version
        return new SensorResult(
            value1: round($load5 * 100 / $cores, 2),
            value2: round($load15 * 100 / $cores, 2),
            uptime: $this->uptime,
            server: "{$cores} cores x {$cpuInfo['ghz']} GHz",
            name1: '% used - 5 min',
            name2: '% used - 15 min',
            description: "{$this->serverName}: CPU% (5/15 min - {$cores} CPUs)",
            mrtgUnit: '%',
            mrtgOptions: 'growright,nobanner,gauge,nopercent',
            mrtgMaxBytes: 1000,
            mrtgKmg: ',k,M,G,T,P',
            url: $this->buildUrl('cpu%'),
            cfgUrl: $this->buildUrl('cpu%', true),
            mrtgName: $this->buildCounterName('cpu%'),
            version: self::VERSION,
        );
    }

    // Similar methods for:
    // - memusage(bool $asPercent = false): SensorResult
    // - battery(string $type = ''): SensorResult
    // - diskusage(?string $path = null, bool $asPercent = false): SensorResult
    // - foldersize(string $folder, array $options = []): SensorResult
    // - filecount(string $folder, array $options = []): SensorResult
    // - proccount(?string $filter = null): SensorResult
    // - pingtime(string $address, int $port = 80): SensorResult
    // - foldercount(string $folder, array $options = []): SensorResult

    private function buildUrl(string $key, bool $withConfig = false): string
    {
        $url = "{$this->baseUrl}?key={$key}";
        return $withConfig ? "{$url}&config=1" : $url;
    }

    private function buildCounterName(string $key): string
    {
        $digest = substr(hash('sha256', $this->serverName), 0, 6);
        return "{$digest}.{$key}";
    }

    public static function sanitize(string $text): string
    {
        return str_replace([';', '"'], '', $text);
    }
}
```

#### 6.2 Create src/Sensor/MrtgFormatter.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Sensor;

final class MrtgFormatter
{
    public static function formatOutput(SensorResult $result, bool $withConfig = false): string
    {
        $output = sprintf(
            "%s\n%s\n%s\n%s\n",
            trim((string)$result->value1),
            trim((string)$result->value2),
            trim($result->uptime),
            trim($result->server)
        );

        if (!$withConfig) {
            $output .= "url_source={$result->cfgUrl}\n";
            $output .= "time_server=" . date('c') . "\n";
            $output .= "id_counter={$result->mrtgName}\n";
            $output .= "version_api={$result->version}\n";
        } else {
            $output .= self::formatConfig($result);
        }

        return $output;
    }

    private static function formatConfig(SensorResult $result): string
    {
        $name = str_replace('%', 'p', $result->mrtgName);

        $config = "#####################################\n";
        $config .= "#### MRTG CONFIG {$name} ####\n";
        $config .= "#####################################\n";
        $config .= "Target[{$name}]: `curl -s \"{$result->url}\"`\n";
        $config .= "Title[{$name}]: {$result->description}\n";
        $config .= "PageTop[{$name}]: <h1>{$result->description}</h1>\n";

        if ($result->name1) {
            $config .= "LegendI[{$name}]: {$result->name1}\n";
            $config .= "Legend1[{$name}]: {$result->name1}\n";
            $config .= "Legend3[{$name}]: â†‘ {$result->name1}\n";
        }

        if ($result->name2) {
            $config .= "LegendO[{$name}]: {$result->name2}\n";
            $config .= "Legend2[{$name}]: {$result->name2}\n";
            $config .= "Legend4[{$name}]: â†‘ {$result->name2}\n";
        }

        $config .= "YLegend[{$name}]: {$result->mrtgUnit}\n";
        $config .= "PNGTitle[{$name}]: {$name}\n";
        $config .= "ShortLegend[{$name}]: {$result->mrtgUnit}\n";
        $config .= "Options[{$name}]: {$result->mrtgOptions}\n";
        $config .= "MaxBytes[{$name}]: {$result->mrtgMaxBytes}\n";
        $config .= "kMG[{$name}]: {$result->mrtgKmg}\n";

        return $config;
    }
}
```

### Phase 7: HTTP Layer

#### 7.1 Create src/Http/Request.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Http;

final readonly class Request
{
    private function __construct(
        public array $query,
        public array $server,
    ) {}

    public static function fromGlobals(): self
    {
        return new self($_GET, $_SERVER);
    }

    public function get(string $key, mixed $default = null): mixed
    {
        return $this->query[$key] ?? $default;
    }

    public function has(string $key): bool
    {
        return isset($this->query[$key]);
    }

    public function getServerName(): string
    {
        return $this->server['SERVER_NAME'] ?? gethostname();
    }

    public function getScriptName(): string
    {
        return $this->server['SCRIPT_NAME'] ?? '/index.php';
    }

    public function isHttps(): bool
    {
        return isset($this->server['HTTPS']) && $this->server['HTTPS'] === 'on';
    }
}
```

#### 7.2 Create src/Http/Response.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Http;

final class Response
{
    public function __construct(
        private readonly string $content,
        private readonly int $statusCode = 200,
        private readonly array $headers = [],
    ) {}

    public function send(): void
    {
        http_response_code($this->statusCode);

        foreach ($this->headers as $name => $value) {
            header("{$name}: {$value}");
        }

        echo $this->content;
    }

    public static function text(string $content, int $statusCode = 200): self
    {
        return new self($content, $statusCode, [
            'Content-Type' => 'text/plain; charset=utf-8',
        ]);
    }

    public static function error(string $message, int $statusCode = 400): self
    {
        return self::text($message, $statusCode);
    }
}
```

### Phase 8: Entry Point

#### 8.1 Create public/index.php
```php
<?php

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use MrtgSensor\Cache\FileCache;
use MrtgSensor\Command\CommandExecutor;
use MrtgSensor\Http\Request;
use MrtgSensor\Http\Response;
use MrtgSensor\OS\OSDetector;
use MrtgSensor\OS\{BusyBoxTools, DarwinTools, LinuxTools, WindowsTools};
use MrtgSensor\Enum\{OSType, SensorType};
use MrtgSensor\Sensor\{Sensor, MrtgFormatter};

// Initialize dependencies
$debug = isset($_GET['debug']);
$cache = new FileCache(__DIR__ . '/../var/cache');
$executor = new CommandExecutor($cache, $debug);

// Detect OS and create appropriate OS tools
$osType = OSDetector::detect();
$osTools = match($osType) {
    OSType::WINDOWS => new WindowsTools($executor),
    OSType::DARWIN => new DarwinTools($executor),
    OSType::BUSYBOX => new BusyBoxTools($executor),
    OSType::LINUX => new LinuxTools($executor),
};

// Create request
$request = Request::fromGlobals();

// Create sensor
$sensor = new Sensor(
    $osTools,
    $request->getServerName(),
    $request->getScriptName(),
    $request->isHttps()
);

// Get parameters
$keyParam = $request->get('key', 'cpu');
$param = $request->get('param');
$options = $request->get('options', '');
$withConfig = $request->has('config');

// Parse sensor type
$sensorType = SensorType::tryFromString($keyParam);
if ($sensorType === null) {
    Response::error("Unknown sensor type: {$keyParam}")->send();
    exit(1);
}

// Execute sensor
try {
    $result = match($sensorType) {
        SensorType::CPU => $sensor->cpuusage(),
        SensorType::CPU_PERCENT => $sensor->cpuusage(true),
        SensorType::MEMORY => $sensor->memusage(),
        SensorType::MEMORY_PERCENT => $sensor->memusage(true),
        SensorType::DISK => $sensor->diskusage($param),
        SensorType::DISK_PERCENT => $sensor->diskusage($param, true),
        SensorType::PROCESS_COUNT => $sensor->proccount($param),
        SensorType::BATTERY => $sensor->battery(''),
        SensorType::BATTERY_PERCENT => $sensor->battery('%'),
        SensorType::BATTERY_INVERSE => $sensor->battery('-'),
        SensorType::BATTERY_VOLTAGE => $sensor->battery('V'),
        SensorType::BATTERY_AMPERE => $sensor->battery('A'),
        SensorType::BATTERY_CYCLES => $sensor->battery('C'),
        SensorType::FOLDER_SIZE => $sensor->foldersize($param ?? '.', $options),
        SensorType::FILE_COUNT => $sensor->filecount($param ?? '.', $options),
        SensorType::FOLDER_COUNT => $sensor->foldercount($param ?? '.', $options),
        SensorType::PING_TIME => $sensor->pingtime($param ?? 'localhost'),
    };

    $output = MrtgFormatter::formatOutput($result, $withConfig);
    Response::text($output)->send();

} catch (\Throwable $e) {
    if ($debug) {
        Response::error(
            "Error: {$e->getMessage()}\n{$e->getTraceAsString()}",
            500
        )->send();
    } else {
        Response::error("Sensor error occurred", 500)->send();
    }
    exit(1);
}
```

### Phase 9: Testing Infrastructure

#### 9.1 Create tests/Unit/Cache/FileCacheTest.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Tests\Unit\Cache;

use MrtgSensor\Cache\FileCache;
use PHPUnit\Framework\TestCase;

final class FileCacheTest extends TestCase
{
    private string $tempDir;
    private FileCache $cache;

    protected function setUp(): void
    {
        $this->tempDir = sys_get_temp_dir() . '/mrtg_test_' . uniqid();
        mkdir($this->tempDir);
        $this->cache = new FileCache($this->tempDir);
    }

    protected function tearDown(): void
    {
        $files = glob("{$this->tempDir}/*");
        foreach ($files as $file) {
            unlink($file);
        }
        rmdir($this->tempDir);
    }

    public function testSetAndGetReturnsValue(): void
    {
        $this->cache->set('test-key', 'test-group', 'test-value');
        $result = $this->cache->get('test-key', 'test-group');

        $this->assertSame('test-value', $result);
    }

    public function testGetReturnsNullWhenExpired(): void
    {
        $this->cache->set('test-key', 'test-group', 'test-value');

        // Get with 0 second max age - should be expired
        $result = $this->cache->get('test-key', 'test-group', 0);

        $this->assertNull($result);
    }

    // Additional tests...
}
```

#### 9.2 Create tests/Integration/SensorIntegrationTest.php
```php
<?php

declare(strict_types=1);

namespace MrtgSensor\Tests\Integration;

use MrtgSensor\Cache\FileCache;
use MrtgSensor\Command\CommandExecutor;
use MrtgSensor\OS\OSDetector;
use MrtgSensor\OS\{LinuxTools, DarwinTools, WindowsTools, BusyBoxTools};
use MrtgSensor\Enum\OSType;
use MrtgSensor\Sensor\Sensor;
use PHPUnit\Framework\TestCase;

final class SensorIntegrationTest extends TestCase
{
    private Sensor $sensor;

    protected function setUp(): void
    {
        $cache = new FileCache(sys_get_temp_dir() . '/mrtg_cache');
        $executor = new CommandExecutor($cache, false);

        $osType = OSDetector::detect();
        $osTools = match($osType) {
            OSType::WINDOWS => new WindowsTools($executor),
            OSType::DARWIN => new DarwinTools($executor),
            OSType::BUSYBOX => new BusyBoxTools($executor),
            OSType::LINUX => new LinuxTools($executor),
        };

        $this->sensor = new Sensor($osTools, 'testserver', '/test.php', false);
    }

    public function testCpuUsageReturnsValidResult(): void
    {
        $result = $this->sensor->cpuusage();

        $this->assertIsNumeric($result->value1);
        $this->assertIsNumeric($result->value2);
        $this->assertNotEmpty($result->server);
        $this->assertNotEmpty($result->description);
    }

    // Additional integration tests...
}
```

### Phase 10: Migration & Cleanup

#### 10.1 Move Static Assets
```bash
mv overview.html public/
mv test.html public/
```

#### 10.2 Create Legacy Compatibility (Optional)
If you need backward compatibility with old URLs, create a compatibility shim:

**public/legacy.php**:
```php
<?php
// Redirect old URLs to new structure
// This allows gradual migration of MRTG configs
require_once __DIR__ . '/index.php';
```

#### 10.3 Update README.md
Add modern installation and usage instructions.

#### 10.4 Update CLAUDE.md
Document new structure, modern patterns, development workflow.

---

## Migration Strategy

### For Existing Deployments

1. **Parallel Deployment**: Deploy new structure alongside old
2. **Test Endpoint Compatibility**: Verify all sensor endpoints return identical data
3. **Update Web Server Config**: Point document root to `public/`
4. **Update MRTG Configs**: Update URLs gradually (or use compatibility layer)
5. **Monitor**: Check error logs for any issues
6. **Remove Legacy**: Once stable, remove old `index.php` and `lib/` directory

### Backward Compatibility

The new API maintains 100% backward compatibility:
- Same URL parameters: `key`, `param`, `options`, `config`, `debug`
- Same output format (MRTG 4-line format)
- Same sensor types and naming

---

## Validation Gates

These commands MUST execute successfully before considering the refactoring complete:

### 1. Install Dependencies
```bash
composer install
```

### 2. Static Analysis (PHPStan Level 8)
```bash
composer analyse
# Must exit with code 0 and no errors
```

### 3. Code Style Check
```bash
composer format -- --dry-run
# Should show no violations or only minor formatting
```

### 4. Apply Code Formatting
```bash
composer format
```

### 5. Run Tests
```bash
composer test
# All tests must pass
```

### 6. Full Check
```bash
composer check
# Runs both analyse and test - must succeed
```

### 7. Manual Endpoint Testing
```bash
# Test each sensor type via curl
curl "http://localhost/index.php?key=cpu"
curl "http://localhost/index.php?key=cpu%"
curl "http://localhost/index.php?key=mem"
curl "http://localhost/index.php?key=disk&param=/"
curl "http://localhost/index.php?key=proc"
curl "http://localhost/index.php?key=cpu&config=1"

# Verify output matches expected MRTG format:
# Line 1: value1 (number)
# Line 2: value2 (number)
# Line 3: uptime (string)
# Line 4: server (string)
# Additional lines: metadata
```

### 8. PHP Syntax Check
```bash
find src -name "*.php" -exec php -l {} \; | grep -v "No syntax errors"
# Should return nothing (all files valid)
```

---

## Common Pitfalls & Solutions

### 1. Command Execution on Different OS
**Issue**: Commands differ across Windows/Linux/macOS
**Solution**: Each OS class has platform-specific implementations. Use `OSDetector` to select correct implementation.

### 2. Cache Directory Permissions
**Issue**: Web server can't write to `var/cache`
**Solution**:
```bash
chmod -R 775 var/cache
chown -R www-data:www-data var/cache  # Linux
# or
chown -R _www:_www var/cache  # macOS
```

### 3. Composer Autoloader Not Found
**Issue**: `vendor/autoload.php` missing
**Solution**: Run `composer install` before accessing application

### 4. Type Errors with Legacy Data
**Issue**: Some OS commands return unexpected data types
**Solution**: Use union types (`int|float|string`) where necessary and validate data

### 5. Breaking Changes in match()
**Issue**: `match` requires exhaustive handling
**Solution**: Always include `default` case or handle all enum values explicitly

---

## Documentation References

### PHP 8.3 Features
- **Official PHP 8.3 Release**: https://www.php.net/releases/8.3/en.php
- Typed class constants
- `#[\Override]` attribute for safer inheritance
- Dynamic class constant fetch syntax
- Deep cloning of readonly properties

### Tools & Standards
- **PHPStan**: https://phpstan.org/user-guide/getting-started
  - Level 8 strict analysis
  - Installation: `composer require --dev phpstan/phpstan`

- **PHPUnit 10**: https://phpunit.de/getting-started/phpunit-10.html
  - Modern testing framework
  - TestCase base class: `PHPUnit\Framework\TestCase`

- **PHP-CS-Fixer**: https://cs.symfony.com/
  - Automated code formatting
  - PSR-12 compliance
  - Installation: `composer require --dev friendsofphp/php-cs-fixer`

### Best Practices
- **PSR-4 Autoloading**: https://www.php-fig.org/psr/psr-4/
- **PSR-12 Coding Style**: https://www.php-fig.org/psr/psr-12/
- **Composer Documentation**: https://getcomposer.org/doc/

---

## Implementation Checklist

- [ ] **Phase 1**: Project setup (composer.json, configs, directories)
- [ ] **Phase 2**: Create enums (SensorType, OSType)
- [ ] **Phase 3**: Create value objects (SensorResult, CommandResult)
- [ ] **Phase 4**: Implement FileCache
- [ ] **Phase 5**: Implement CommandExecutor
- [ ] **Phase 6**: Implement OSDetector and OSTools hierarchy
- [ ] **Phase 7**: Implement OS-specific tools (Windows, Linux, Darwin, BusyBox)
- [ ] **Phase 8**: Implement Sensor class with all methods
- [ ] **Phase 9**: Implement MrtgFormatter
- [ ] **Phase 10**: Implement HTTP layer (Request, Response)
- [ ] **Phase 11**: Create public/index.php entry point
- [ ] **Phase 12**: Move static assets to public/
- [ ] **Phase 13**: Write unit tests
- [ ] **Phase 14**: Write integration tests
- [ ] **Phase 15**: Run all validation gates
- [ ] **Phase 16**: Update documentation (README, CLAUDE.md)
- [ ] **Phase 17**: Test all sensor endpoints manually
- [ ] **Phase 18**: Compare output with legacy version
- [ ] **Phase 19**: Update .gitignore
- [ ] **Phase 20**: Final code review and cleanup

---

## Success Criteria

### Technical Requirements
âœ… All code passes PHPStan level 8 analysis
âœ… All code formatted to PSR-12 standards
âœ… All unit tests pass
âœ… All integration tests pass
âœ… PHP 8.3+ type safety enforced everywhere
âœ… PSR-4 autoloading working correctly
âœ… Composer scripts execute successfully

### Functional Requirements
âœ… All 17 sensor types work correctly
âœ… Output format matches legacy MRTG format exactly
âœ… Config generation (`config=1`) produces valid MRTG config
âœ… Caching works and improves performance
âœ… Debug mode provides useful information
âœ… Error handling doesn't expose sensitive info
âœ… Works on Windows, Linux, macOS, and BusyBox

### Quality Requirements
âœ… Code is maintainable and well-documented
âœ… Clear separation of concerns
âœ… No global state or variables
âœ… Dependency injection used throughout
âœ… Immutable value objects where appropriate
âœ… Proper error handling with typed exceptions

---

## PRP Quality Self-Assessment

### Context Completeness: âœ… Excellent
- Full codebase analysis included
- All legacy classes and methods documented
- Current architecture clearly explained
- Migration path defined

### Implementation Clarity: âœ… Excellent
- 20-phase step-by-step blueprint
- Code examples for every major component
- Modern PHP 8.3+ patterns demonstrated
- OS-specific implementation strategy clear

### Validation Rigor: âœ… Excellent
- 8 executable validation gates
- Composer scripts for automation
- Manual testing procedures
- Success criteria clearly defined

### Reference Quality: âœ… Good
- Official PHP documentation linked
- Tool-specific guides included
- Best practice standards referenced
- Could benefit from more GitHub examples

### Error Anticipation: âœ… Excellent
- Common pitfalls section included
- OS-specific issues addressed
- Permission and deployment concerns covered
- Type safety edge cases noted

### One-Pass Viability: âœ… High Confidence

**Confidence Score: 8.5/10**

### Strengths:
1. Comprehensive blueprint with code examples
2. Clear migration strategy preserving backward compatibility
3. Executable validation gates
4. Well-researched modern PHP patterns
5. Detailed OS abstraction strategy

### Potential Challenges:
1. OS-specific implementations require testing on each platform (might need iteration)
2. Battery sensor only works on macOS - needs graceful degradation
3. Some legacy quirks in command parsing may surface during testing
4. Performance regression testing not specified
5. Could use more specific examples of tricky refactorings (e.g., foldersize with COM on Windows)

### Mitigation:
- Run validation gates frequently during implementation
- Test each OS class independently as soon as created
- Keep legacy codebase available for comparison
- Use Docker containers for cross-platform testing
- Add performance benchmarks to integration tests

---

## Final Notes for AI Agent

**Critical Context:**
- The legacy codebase is WORKING PRODUCTION CODE
- Maintain 100% API backward compatibility
- MRTG output format is strict - must match exactly
- Some OS-specific commands are fragile - handle errors gracefully
- The `Sensor::sanitize()` method prevents command injection - preserve this security feature

**Implementation Order:**
Follow the phases sequentially. Don't skip Phase 1 setup or later phases will fail. Test each phase before moving to the next.

**Testing Strategy:**
1. Write tests alongside implementation
2. Run PHPStan after each class is created
3. Test on your development OS first
4. Use Docker for other OS testing
5. Compare output byte-by-byte with legacy version

**If Blocked:**
1. Check composer autoload is regenerated (`composer dump-autoload`)
2. Verify PHP version is 8.3+ (`php -v`)
3. Check file permissions on var/cache
4. Enable debug mode for detailed errors
5. Refer to legacy implementation in lib/ for complex logic

**Quality Bar:**
This is a comprehensive refactoring. Do not compromise on:
- Type safety (use strict types everywhere)
- Error handling (never silently fail)
- Code formatting (PSR-12 compliance)
- Testing (100% coverage of business logic)
- Documentation (PHPDoc on all public methods)

Good luck! ðŸš€
